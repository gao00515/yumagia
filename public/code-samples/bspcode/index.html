<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <link rel="stylesheet" href="https:&#x2F;&#x2F;yumagia.dev/main.css">
  <title>yumagia</title>
</head>

<body>
  <section class="section">
    <div class="container">
      
<hr class="title">
<h1 class="title"><a href="https://yumagia.dev">YUMAGIA.DEV</a> : <a href="https://yumagia.dev/code-samples/">CODE SAMPLES</a></h1>
<hr class="title">

<h1 class="title">
  Gamma Engine BSP Code Translated
</h1>
<p class="subtitle"><strong>A C translation of the BSP tree generation function which I wrote for the Gamma Engine project.</strong></p>

<p>(9 Dec 2024) This is still in progress! I just wrote this page so there may be errors until the afternoon!</p>
<p>(10 Dec 2024) Added C code. Might have errors that I haven't fixed yet...</p>
<p>Here is the BSP tree generation code for Gamma Engine. It creates a solid-leaf BSP tree, given a set of polygons from a lazy mesh. I originally wrote this in Scratch, but wanted to make a more understandable translation in pseudocode. After writing a quick pseudocode, and realizing it would actually be useful(and more fun!) to outright write it in C, I decided to just simply make the entire function along with its structure defs in C language. I decided to keep the pseudocode anyways since it was an important step I used to translate the Scratch code into C. The C/pseudocode is provided below the scratch blocks.</p>
<div class="figure2">
    <img src ="bspgeneratetreescratch.png"/>
</div>
<p>This was the translated pseudocode I threw together overnight. It's full of problems and might not be very helpful to read, but I'm keeping it because it did help me write the C code in the snippet further below this one.</p>
<pre data-lang="txt" style="background-color:#2b303b;color:#c0c5ce;" class="language-txt "><code class="language-txt" data-lang="txt"><span>function bsp_gen(lower, upper, side, parent)
</span><span>    IF upper.next = lower THEN
</span><span>        add_node(null, null, null, side, parent) //adds a solid leaf
</span><span>        return
</span><span>    greedy_select_pivot(lower, upper)
</span><span>    gen_bounding_geometry(lower, upper)
</span><span>    IF pivot = null THEN
</span><span>        stabilize_sort(lower, upper)
</span><span>        IF not right? THEN
</span><span>            add_node(null, null, null, side, parent)
</span><span>            return
</span><span>        add set to air leaf, inherit parent
</span><span>        add_node(lower, upper, null, side, parent) //add air leaf
</span><span>    ELSE
</span><span>        partition(lower, upper)
</span><span>        IF parent = null THEN
</span><span>            add_node(partitionhead, pivot, &amp;pivot, null, parent) //adds an internal node 
</span><span>        ELSE
</span><span>            add_node(partitionhead, pivot, &amp;pivot, side, parent)
</span><span>        bsp_gen(lower, pivot, left, *newnode)
</span><span>        bsp_gen(lower.next, upper, right, *newnode)
</span></code></pre>
<p>... And I wrote the C translation, starting with all of the typedefs specific to the program:</p>
<pre data-linenos data-lang="h" style="background-color:#2b303b;color:#c0c5ce;" class="language-h "><code class="language-h" data-lang="h"><table><tbody><tr><td>1</td><td><span style="color:#b48ead;">typedef struct</span><span> plane_s
</span></td></tr><tr><td>2</td><td><span>{
</span></td></tr><tr><td>3</td><td><span>    vec3_t              normal, point;
</span></td></tr><tr><td>4</td><td><span>    </span><span style="color:#b48ead;">struct</span><span> plane_s      *hash_chain;
</span></td></tr><tr><td>5</td><td><span>} plane_t;
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span style="color:#b48ead;">typedef struct</span><span> ptnplane_s {
</span></td></tr><tr><td>8</td><td><span>    </span><span style="color:#b48ead;">int</span><span>                 planenum;
</span></td></tr><tr><td>9</td><td><span>    </span><span style="color:#b48ead;">int</span><span>                 tested;	
</span></td></tr><tr><td>10</td><td><span>    </span><span style="color:#b48ead;">struct</span><span> ptnplane_s   
</span></td></tr><tr><td>11</td><td><span>} ptnplane_t;
</span></td></tr><tr><td>12</td><td><span>
</span></td></tr><tr><td>13</td><td><span style="color:#b48ead;">typedef struct</span><span> face_s {
</span></td></tr><tr><td>14</td><td><span>    </span><span style="color:#b48ead;">struct</span><span> face_s       *next;
</span></td></tr><tr><td>15</td><td><span>    winding_t           *w;
</span></td></tr><tr><td>16</td><td><span>    </span><span style="color:#b48ead;">int</span><span>                 planenum;
</span></td></tr><tr><td>17</td><td><span>    </span><span style="color:#b48ead;">int</span><span>                 numverts;
</span></td></tr><tr><td>18</td><td><span>    ptnplane_t          *original
</span></td></tr><tr><td>19</td><td><span>} face_t;
</span></td></tr><tr><td>20</td><td><span>
</span></td></tr><tr><td>21</td><td><span style="color:#b48ead;">typedef struct</span><span> node_s {
</span></td></tr><tr><td>22</td><td><span>    </span><span style="color:#65737e;">//leaves and internal nodes
</span></td></tr><tr><td>23</td><td><span>    </span><span style="color:#b48ead;">int</span><span>                 planenum;           </span><span style="color:#65737e;">// -1 = leaf node
</span></td></tr><tr><td>24</td><td><span>    </span><span style="color:#b48ead;">struct</span><span> node_s       *parent;
</span></td></tr><tr><td>25</td><td><span>    vec3_t              minb, maxb;&lt;br&gt;
</span></td></tr><tr><td>26</td><td><span>    </span><span style="color:#65737e;">//nodes only
</span></td></tr><tr><td>27</td><td><span>    ptnplane_t          *ptnplane;
</span></td></tr><tr><td>28</td><td><span>    </span><span style="color:#b48ead;">struct</span><span> node_s       *children[</span><span style="color:#d08770;">2</span><span>];
</span></td></tr><tr><td>29</td><td><span>    </span><span style="color:#65737e;">//leaves only
</span></td></tr><tr><td>30</td><td><span>    face_t              *facelist;
</span></td></tr><tr><td>31</td><td><span>} node_t;
</span></td></tr></tbody></table></code></pre>
<p>(I did not include the any of the more general typedefs such as <code>vec3_t</code> and <code>winding_t</code>, but you would need them in order to describe the geometric primitives)</p>
<p>... And then the definitions of <code>bspgen</code>:</p>
<pre data-linenos data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><table><tbody><tr><td>1</td><td><span>node_t *</span><span style="color:#8fa1b3;">bspgen</span><span>(node_t *</span><span style="color:#bf616a;">node</span><span>, face_t *</span><span style="color:#bf616a;">faces</span><span>) {
</span></td></tr><tr><td>2</td><td><span>    node_t              *newnode;
</span></td></tr><tr><td>3</td><td><span>    ptnplane_t          *pivot;&lt;br&gt;
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>    pivot = </span><span style="color:#bf616a;">greedyselect</span><span>(faces);
</span></td></tr><tr><td>6</td><td><span>    </span><span style="color:#b48ead;">if </span><span>(!pivot) {
</span></td></tr><tr><td>7</td><td><span>        </span><span style="color:#65737e;">//We add a leaf
</span></td></tr><tr><td>8</td><td><span>        node-&gt;side = </span><span style="color:#d08770;">NULL</span><span>;
</span></td></tr><tr><td>9</td><td><span>        node-&gt;planenum = -</span><span style="color:#d08770;">1</span><span>;
</span></td></tr><tr><td>10</td><td><span>        node-&gt;facelist = faces;
</span></td></tr><tr><td>11</td><td><span>        </span><span style="color:#b48ead;">return</span><span> node;
</span></td></tr><tr><td>12</td><td><span>    }
</span></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span>    node-&gt;ptnplane = pivot;
</span></td></tr><tr><td>15</td><td><span>    node-&gt;planenum = pivot-&gt;planenum &amp; ~</span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#65737e;">// From Quake II. It&#39;s more cumbersome in Scratch
</span></td></tr><tr><td>16</td><td><span>    
</span></td></tr><tr><td>17</td><td><span>    newnode = </span><span style="color:#bf616a;">AllocNode</span><span>();
</span></td></tr><tr><td>18</td><td><span>    newnode-&gt;parent = node;
</span></td></tr><tr><td>19</td><td><span>    node-&gt;children[</span><span style="color:#d08770;">1</span><span>] = newnode;
</span></td></tr><tr><td>20</td><td><span>    newnode = </span><span style="color:#bf616a;">AllocNode</span><span>();
</span></td></tr><tr><td>21</td><td><span>    newnode-&gt;parent = node;
</span></td></tr><tr><td>22</td><td><span>    node-&gt;children[</span><span style="color:#d08770;">2</span><span>] = newnode;
</span></td></tr><tr><td>23</td><td><span>
</span></td></tr><tr><td>24</td><td><span>    </span><span style="color:#bf616a;">SplitFaces</span><span>(node-&gt;planenum);
</span></td></tr><tr><td>25</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Much of the code is quite akin to that of the BSP tool in the idTech 2 lineage.</p>
<!-- ptnplane_s *greedyselect() {
    int                 val, bestval;
    ptnplane_t          *current, *pivot;
} -->


    </div>
  </section>
</body>

</html>

